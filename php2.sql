-- phpMyAdmin SQL Dump
-- version 4.4.15.7
-- http://www.phpmyadmin.net
--
-- Хост: 127.0.0.1:3306
-- Время создания: Май 30 2017 г., 12:01
-- Версия сервера: 5.5.50
-- Версия PHP: 5.5.37

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `php2`
--
CREATE DATABASE IF NOT EXISTS `php2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
USE `php2`;

-- --------------------------------------------------------

--
-- Структура таблицы `articles`
--

CREATE TABLE IF NOT EXISTS `articles` (
  `id_article` int(11) NOT NULL,
  `title` varchar(30) DEFAULT NULL,
  `content` text
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `articles`
--

INSERT INTO `articles` (`id_article`, `title`, `content`) VALUES(22, 'php', 'Область применения[править | править вики-текст]\r\nВ области веб-программирования, в частности серверной части, PHP — один из популярных сценарных языков (наряду с JSP, Perl и языками, используемыми в ASP.NET).\r\n\r\nПопулярность в области построения веб-сайтов определяется наличием большого набора встроенных средств для разработки веб-приложений[13]. Основные из них:\r\n\r\nавтоматическое извлечение POST и GET-параметров, а также переменных окружения веб-сервера в предопределённые массивы;\r\nвзаимодействие с большим количеством различных систем управления базами данных (MySQL, MySQLi, SQLite, PostgreSQL, Oracle (OCI8), Oracle, Microsoft SQL Server, Sybase, ODBC, mSQL, IBM DB2, Cloudscape и Apache Derby, Informix, Ovrimos SQL, Lotus Notes, DB++, DBM, dBase, DBX, FrontBase, FilePro, Ingres II, SESAM, Firebird / InterBase, Paradox File Access, MaxDB, Интерфейс PDO);\r\nавтоматизированная отправка HTTP-заголовков;\r\nработа с HTTP-авторизацией;\r\nработа с cookies и сессиями;\r\nработа с локальными и удалёнными файлами, сокетами;\r\nобработка файлов, загружаемых на сервер;\r\nработа с XForms.\r\nВ настоящее время PHP используется сотнями тысяч разработчиков. Согласно рейтингу корпорации TIOBE, базирующемся на данных поисковых систем, в мае 2016 года PHP находился на 6 месте среди языков программирования[11]. К крупнейшим сайтам, использующим PHP, относятся Facebook, Wikipedia и др.\r\n\r\nВходит в LAMP — распространённый набор программного обеспечения для создания и хостинга веб-сайтов (Linux, Apache, MySQL, PHP).\r\n\r\nСоздание GUI-приложений[править | править вики-текст]\r\n\r\nСкриншот редактора форм WinBinder\r\nХотя PHP и не слишком распространён в данной области, его можно использовать и для создания GUI-приложений.\r\n\r\nДля создания кроссплатформенных приложений служат пакеты PHP-GTK и PHP-Qt, представляющие собой обёртки для соответствующих популярных библиотек виджетов. Также существует среда разработки кроссплатформенных приложений Devel Next[14].\r\n\r\nДля создания графических приложений для Windows существуют свободные пакеты WinBinder (написан на Си, фактически — обёртка для WinAPI), PQBuilder (написан на PHP с использованием библиотеки PHPQt5), а также предшественник Devel Next — среда быстрой разработки Devel Studio[15].\r\n\r\nКроме этого существует реализация PHP для .NET/Mono — Phalanger и для JVM — JPHP, результатом компиляции PHP-кода в Phalanger может быть любое .NET-приложение, в то же время JPHP поддерживает расширение Swing, почти полностью портированное из среды Java.\r\n\r\nИстория[править | править вики-текст]\r\nОсновная статья: История PHP\r\nВ 1994 году датский программист Расмус Лердорф создал набор скриптов на Perl/CGI для вывода и учёта посетителей его онлайн-резюме, обрабатывающий шаблоны HTML-документов. Лердорф назвал набор Personal Home Page (Личная Домашняя Страница). Вскоре функциональности и быстроты Perl — интерпретатора скриптов — перестало хватать, и Лердорф разработал с использованием языка C новый интерпретатор шаблонов PHP/FI (англ. Personal Home Page / Forms Interpreter — «персональная домашняя страница / интерпретатор форм»)[16].\r\n\r\n8 июня 1995 года, вышел PHP/FI 2.0 — первый публичный релиз.\r\n\r\nВ 1997 году после длительного бета-тестирования вышла вторая версия обработчика, написанного на C — PHP/FI 2.0. Её использовали около 1 % (приблизительно 50 тысяч) всех интернет-доменов мира[9].\r\n\r\nВерсия PHP 3.0 подверглась значительной переработке, определившей современный облик и стиль языка программирования. В 1997 году два израильских программиста, Энди Гутманс и Зеев Сураски, полностью переписали код интерпретатора. PHP 3.0 был официально выпущен в июне 1998 года.[9]\r\n\r\nОдной из сильнейших сторон PHP 3.0 была возможность расширения ядра дополнительными модулями. Впоследствии интерфейс написания расширений привлёк к PHP множество сторонних разработчиков, работающих над своими модулями, что дало PHP возможность работать с огромным количеством баз данных, протоколов, поддерживать большое число API. Большое количество разработчиков привело к быстрому развитию языка и стремительному росту его популярности. С этой версии акроним php расшифровывается как «PHP: hypertext Preprocessor», вместо устаревшего «Personal Home Page».\r\n\r\nК зиме 1998 года, практически сразу после официального выхода PHP 3.0, Энди Гутманс и Зеев Сураски начали переработку ядра PHP. В задачи входило увеличение производительности сложных приложений и улучшение модульности базиса кода PHP. Новый движок, названный Zend Engine, успешно справлялся с поставленными задачами и впервые был представлен в середине 1999 года. PHP 4.0, основанный на этом движке и принёсший с собой набор дополнительных функций, официально вышел в мае 2000 года. В дополнение к улучшению производительности, PHP 4.0 имел ещё несколько ключевых нововведений, таких как поддержка сессий, буферизация вывода, более безопасные способы обработки вводимой пользователем информации и несколько новых языковых конструкций.\r\n\r\nПятая версия PHP была выпущена разработчиками 13 июля 2004 года. Изменения включают обновление ядра Zend (Zend Engine 2), что существенно увеличило эффективность интерпретатора. Введена поддержка языка разметки XML. Полностью переработаны функции ООП, которые стали во многом схожи с моделью, используемой в Java. В частности, введён деструктор, открытые, закрытые и защищённые члены и методы, окончательные члены и методы, интерфейсы и клонирование объектов. В последующих версиях также были введены пространства имён, замыкания и целый ряд достаточно серьёзных изменений, количественно и качественно сравнимых с теми, которые появились при переходе на PHP 5.0.\r\n\r\nШестая версия PHP разрабатывалась[17] с октября 2006 года. Было сделано[18][19] множество нововведений, как, например, исключение из ядра регулярных выражений POSIX и «длинных» суперглобальных массивов, удаление директив safe_mode, magic_quotes_gpc и register_globals из конфигурационного файла php.ini. Одним из основных новшеств должна была стать поддержка Юникода.[20]. Однако в марте 2010 года разработка PHP6 была признана бесперспективной[21] из-за сложностей с поддержкой Юникода. Исходный код PHP6 перемещён на ветвь, а основной линией разработки стала версия 5.4.\r\n\r\nPHP 7[править | править вики-текст]\r\nВ 2014 году было проведено голосование, по результатам которого следующая версия получила название PHP 7[22]. Выход новой версии планировался в середине октября 2015 года[23]. В марте 2015 года Zend представили инфографику в которой описаны основные нововведения PHP 7[24].\r\n\r\n3 декабря 2015 года было объявлено о выходе PHP версии 7.0.0.[25]\r\n\r\nНовая версия основывается на экспериментальной ветви PHP, которая изначально называлась phpng (PHP Next Generation — следующее поколение), и разрабатывалась с упором на увеличение производительности и уменьшение потребления памяти[26]. В новой версии добавлена возможность указывать тип возвращаемых из функции данных[27], добавлен контроль передаваемых типов для скалярных данных[28], а также новые операторы.\r\n\r\nСинтаксис[править | править вики-текст]\r\nPHPCode HelloWorld.svg\r\nЛоготип Викиучебника Имеется викиучебник по теме\r\n«PHP»\r\nСинтаксис PHP подобен синтаксису языка Си. Некоторые элементы, такие как ассоциативные массивы и цикл foreach, заимствованы из Perl.\r\n\r\nДля работы программы не требуется описывать какие-либо переменные, используемые модули и т. п. Любая программа может начинаться непосредственно с оператора PHP.\r\n\r\nПростейшая программа Hello world на PHP выглядит следующим образом:\r\n\r\n<?php\r\n  echo ''Hello, world!''; \r\n?>\r\nТакже возможен более короткий вариант вывода строки:\r\n\r\n<?= ''Hello, world!'' ?>\r\nОткрывающий тег вида <?= используется для сокращённой записи конструкций используемых для вывода строки.\r\n\r\nPHP исполняет код, находящийся внутри ограничителей, таких как <?php ?>. Всё, что находится вне ограничителей, выводится без изменений. В основном это используется для вставки PHP-кода в HTML-документ, например, так:\r\n\r\n<html>\r\n   <head>\r\n      <title>\r\n         Тестируем PHP\r\n      </title>\r\n   </head>\r\n   <body>\r\n      <?php\r\n         echo "Привет мир!";\r\n      ?>\r\n   </body>\r\n</html>\r\nПомимо ограничителей <?php ?>, допускается использование сокращённого варианта <? ?>. Кроме того, до версии 7.0 допускалось использование ограничителей языка программирования ASP <% %> и <script language="php"> </script>. Работа сокращённых конструкций определяется в конфигурационном файле php.ini.\r\n\r\nИмена переменных начинаются с символа $, тип переменной объявлять не нужно. Имена переменных и констант чувствительны к регистру символов. Имена классов, методов классов и функций к регистру символов не чувствительны. Переменные обрабатываются в строках, заключённых в двойные кавычки, и heredoc-строках (строках, созданных при помощи оператора <<<). Переменные в строках, заключённых в одинарные кавычки, не обрабатываются.\r\n\r\nPHP рассматривает переход на новую строку как пробел, так же как HTML и другие языки со свободным форматом. Инструкции разделяются с помощью точки с запятой (;), за исключением некоторых случаев, после объявления конструкции if/else и циклов.\r\n\r\nПеременные в функцию можно передавать как по значению, так и по ссылке (используется знак &).\r\n\r\nPHP поддерживает три типа комментариев: в стиле языка Си (ограниченные /* */), C++ (начинающиеся с // и идущие до конца строки) и оболочки UNIX (с # до конца строки).\r\n\r\nТипы данных[править | править вики-текст]\r\nPHP является языком программирования с динамической типизацией, не требующим указания типа при объявлении переменных, равно как и самого объявления переменных. Преобразования между скалярными типами зачастую осуществляются неявно без дополнительных усилий (впрочем, PHP предоставляет широкие возможности и для явного преобразования типов).\r\n\r\nК скалярным типам данных относятся:\r\n\r\nцелый тип (integer),\r\nвещественный тип данных (float, double),\r\nлогический тип (boolean),\r\nстроковый тип (string),\r\nи специальный тип NULL.\r\nК нескалярным типам относятся:\r\n\r\n«ресурс» (resource),\r\nмассив (array),\r\nобъект (object),\r\nК псевдотипам[29] относятся:\r\n\r\nmixed любой тип\r\nnumber число (integer либо float)\r\ncallback (string или анонимная функция)\r\nvoid отсутствие параметров\r\nДиапазон целых чисел (integer) в PHP зависит от платформы (обычно, это диапазон 32-битных знаковых целых чисел, то есть, от −2 147 483 648 до 2 147 483 647). Числа можно задавать в десятичной, восьмеричной и шестнадцатеричной системах счисления. Диапазон вещественных чисел (double) также зависит от платформы (для 32-битной архитектуры диапазон позволяет оперировать числами от ±1.7×10−308 до ±1.7×10+308).\r\n\r\nPHP предоставляет разработчикам логический тип (boolean), способный принимать только два значения TRUE («истина») и FALSE («ложь»). При преобразовании в логический тип число 0, пустая строка, ноль в строке «0», NULL и пустой массив считаются равными FALSE. Все остальные значения автоматически преобразуются в TRUE.\r\n\r\nСпециальный тип NULL предназначен для переменных без определённого значения. Единственным значением данного типа является константа NULL. Тип NULL принимают неинициализированные переменные, переменные инициализированные константой NULL, а также переменные, удалённые при помощи конструкции unset().\r\n\r\nСсылки на внешние ресурсы имеют тип «ресурс» (resource). Переменные данного типа, как правило, представляют собой дескриптор, позволяющий управлять внешними объектами, такими как файлы, динамические изображения, результирующие таблицы базы данных и т. п.\r\n\r\nМассивы (array) поддерживают числовые и строковые ключи и являются гетерогенными. Массивы могут содержать значения любых типов, включая другие массивы. Порядок элементов и их ключей сохраняется. Не совсем корректно называть php-массивы массивами, на самом деле это, скорее всего, упорядоченный хеш. Возможно неожиданное поведение при использовании цикла for со счетчиком вместо foreach. Так, например, при сортировке массива с численными индексами функциями из стандартной библиотеки, сортируются и ключи тоже.\r\n\r\nУказатель на функцию в PHP может быть представлен замыканием или псевдотипом callback. Замыкание доступно с версии 5.3 и в коде выглядит как простое определение функции, в которую можно явно пробросить значения из контекста, например:\r\n\r\n function($args, $argsN) use ($ctxVar, $ctxVar1) { ... }\r\ncallback тип может быть представлен:\r\n\r\nстрокой (интерпретируется как название функции);\r\nмассивом где нулевой и первый элемент — строки (интерпретируется как название статической функции класса);\r\nмассивом где нулевой элемент — объект, а первый — строка (интерпретируется как метод у объекта).\r\nДля проверки является ли значение вызываемым следует использовать is_callable($var)\r\n\r\nОбращение к переменным и функциям[править | править вики-текст]\r\nОбращение к переменным осуществляется с помощью символа $, за которым следует имя переменной. Данная конструкция может быть применена также для создания динамических переменных и функций.[30] Например:\r\n\r\n$a = ''I am a''; // Запись значения в переменную $a\r\necho $a; // Вывод переменной $а\r\n\r\n$b = ''a'';\r\necho $$b; // Вывод переменной $а (дополнительный $ перед переменной $b)\r\n\r\necho ${''a''}; // Вывод переменной $a\r\n\r\nfunction_name(); // Вызов функции function_name\r\n$c = ''function_name'';\r\n$c(); // Вызов функции function_name\r\n\r\n$d = ''Class_name'';\r\n$obj = new Class_name; // Создание объекта класса Class_name\r\n$obj = new $d(); // Создание объекта класса Class_name\r\n\r\n$obj->b; // Обращение к полю b объекта\r\n$obj->c(); // Вызов метода c() объекта\r\n\r\n$obj->$b; // Обращение к полю a объекта, так как $b = ''a''\r\n$obj->$c(); // Вызов метода function_name() объекта, так как $c = ''function_name''\r\nВ PHP echo и print не являются функциями[31] (хотя print имеет возвращаемое значение), а являются синтаксическими единицами. При их использовании можно опустить скобки.\r\n\r\nСуперглобальные массивы[править | править вики-текст]\r\nСуперглобальными массивами (англ. Superglobal arrays) в PHP называются предопределённые массивы, имеющие глобальную область видимости без использования директивы global. Большая часть этих массивов содержит входные данные запроса пользователя (параметры GET-запроса, поля форм при посылке методом POST, куки и т. п.).\r\n\r\nВсе суперглобальные массивы, кроме $GLOBALS и $_REQUEST, имеют устаревшие аналоги с длинными именами, которые доступны вплоть до версии 5.3. х (начиная с 5.4.0 были удалены). Таким образом, обращения $_GET[''year''] и $HTTP_GET_VARS[''year''] идентичны (за исключением области видимости: массивы с «длинными» именами не являются суперглобальными).\r\n\r\n$GLOBALS\r\nМассив всех глобальных переменных (в том числе и пользовательских).\r\n$_SERVER (аналог для устаревшего — $HTTP_SERVER_VARS)\r\nСодержит переменные окружения, которые операционная система передаёт серверу.\r\n$_ENV (уст. $HTTP_ENV_VARS)\r\nТекущие переменные среды (англ. Environment variables). Их набор специфичен для платформы, на которой выполняется скрипт.\r\n$_GET (уст. $HTTP_GET_VARS)\r\nСодержит параметры GET-запроса, переданные в URI после знака вопроса «?».\r\n$_POST (уст. $HTTP_POST_VARS)\r\nАссоциативный массив значений полей HTML-формы при отправке методом POST. Индексы элементов соответствуют значению свойства name объектов(кнопки, формы, радио-кнопки, флажки и т. д.) HTML-формы.\r\n$_FILES (уст. $HTTP_POST_FILES)\r\nАссоциативный массив со сведениями об отправленных методом POST файлах. Каждый элемент имеет индекс, идентичный значению атрибута «name» в форме, и, в свою очередь, также является массивом со следующими элементами:\r\n[''name''] — исходное имя файла на компьютере пользователя.\r\n[''type''] — указанный агентом пользователя MIME-тип файла. PHP не проверяет его, и поэтому нет никаких гарантий, что указанный тип соответствует действительности.\r\n[''size''] — размер файла в байтах.\r\n[''tmp_name''] — полный путь к файлу во временной папке. Файл необходимо переместить оттуда функцией move_uploaded_file. Загруженные файлы из временной папки PHP удаляет самостоятельно.\r\n[''error''] — код ошибки. Если файл удачно загрузился, то этот элемент будет равен 0 (UPLOAD_ERR_OK).\r\n$_COOKIE (уст. $HTTP_COOKIE_VARS)\r\nАссоциативный массив с переданными агентом пользователя значениями куки.\r\n$_REQUEST\r\nСодержит элементы из массивов $_GET, $_POST, $_COOKIE. С версии PHP 4.1 включает $_FILES.\r\n$_SESSION (уст. $HTTP_SESSION_VARS)\r\nСодержит данные сессии.\r\nОбъектно-ориентированное программирование[править | править вики-текст]\r\nКлючевое слово class было зарезервировано ещё в третьей версии языка. В четвёртой версии стало возможно создавать классы и объекты на их основе. Однако принципы ООП поддерживались лишь частично, так например, все члены (переменные и методы) были открыты. К тому же создание объектов было дорогой операцией и работали они медленно.\r\n\r\nНачиная с пятой версии PHP обладает полной поддержкой ООП. Работа с классами была оптимизирована и теперь такой код работает достаточно быстро.\r\n\r\nКласс в PHP объявляется с помощью ключевого слова class. Методы и поля класса могут быть общедоступными (public, по умолчанию), защищёнными (protected) и скрытыми (private). PHP поддерживает все три основных механизма ООП — инкапсуляцию, полиморфизм подтипов и наследование (родительский класс указывается с помощью ключевого слова extends после имени класса). Поддерживаются интерфейсы (ставятся в соответствие с помощью implements). Разрешается объявление финальных, абстрактных методов и классов. Множественное наследование классов не поддерживается, однако класс может реализовывать несколько интерфейсов. Для обращения к методам родительского класса используется ключевое слово parent.\r\n\r\nНачиная с версии 5.4.0 множественное наследование может быть реализовано с помощью механизма особенностей (англ. trait). Особенности похожи на примеси (англ. mixins), за исключением того что для них нельзя напрямую создать экземпляр. Повторное использование кода заключено в использовании кода особенности в нескольких классах. Допускается использовать в одном классе несколько особенностей. Механизм особенностей имеет средства разрешения конфликтов имён. При запуске программы код особенности будет «вкомпилирован» в код содержащего его класса.\r\n\r\nКлассы в PHP имеют ряд «магических» методов (англ. magic methods), начинающихся с двух символов подчёркивания. Особо стоит отметить конструктор (__construct(), в версиях до 5.0 конструктором служил метод, одноимённый с классом) и деструктор (__destruct()), а также методы чтения (__get()) и записи (__set()), свёртывания (__sleep()) и развёртывания (__wakeup()), клонирования (__clone()) и др. Эти методы являются достаточно гибким инструментом: переопределяя их, можно добиться существенного изменения поведения объекта.\r\n\r\nВсе функции-члены реализованы виртуальными и потому все они являются методами.\r\n\r\nЭкземпляры класса создаются с помощью ключевого слова new, обращение к полям и методам объекта производится с использованием оператора ->. Для доступа к членам класса из его методов используется переменная $this.\r\n\r\nclass C1 extends C2 implements I1, I2\r\n{\r\n  private $a;\r\n  protected $b;\r\n\r\n  function __construct($a, $b)\r\n  {\r\n    parent::__construct($a, $b);\r\n    $this->a = $a;\r\n    $this->b = $b;\r\n  }\r\n\r\n  public function plus()\r\n  {\r\n    return $this->a + $this->b;\r\n  }\r\n/* ............... */\r\n}\r\n\r\n$d = new C1(1, 2);\r\necho $d->plus(); // 3\r\nНачиная с пятой версии PHP, объекты передаются по ссылке:\r\n\r\nclass a \r\n{\r\n  public $color = ''red'';\r\n}\r\n\r\n$a = new a();\r\necho $a -> color; // red\r\n$b = $a;\r\n$b -> color = ''blue'';\r\necho $a -> color; // blue\r\n«Paamayim Nekudotayim» (иврит: פעמיים נקודתיים) или просто «двойное двоеточие». Используя эту лексему, программист может обращаться к константам, статическим или перегруженным свойствам или методам класса. При обращении к этим элементам извне класса, программист должен использовать имя этого класса. «Paamayim Nekudotayim» на первый взгляд может показаться странным словосочетанием для обозначения двойного двоеточия. Однако во время создания Zend Engine версии 0.5 (который входил в PHP3), Andi и Zeev выбрали[32] именно это обозначение. «Paamayim Nekudotayim» действительно значит «двойное двоеточие» (дословно: «два раза двоеточие») на иврите. Это обозначение не менялось ни разу в течение всего времени разработки PHP[33].\r\n\r\n<?php\r\nclass MyClass {\r\n  const CONST_VALUE = ''Значение константы'';\r\n}\r\n// Использование :: вне объявления класса\r\necho MyClass::CONST_VALUE;\r\n?>\r\nФреймворки и системы управления содержимым[править | править вики-текст]\r\n\r\nСписок примеров в этой статье или её разделе не основывается на обобщающих авторитетных источниках непосредственно о предмете статьи или её раздела.\r\nДобавьте ссылки на источники, предметом рассмотрения которых является тема настоящей статьи (или раздела) в целом, содержащие данные элементы списка как примеры. В противном случае раздел может быть удалён.\r\nСамые современные и наиболее популярные:\r\n\r\nPhalcon\r\nSymfony\r\nLaravel\r\nKohana\r\nYii\r\nCodeigniter\r\nZend Framework\r\nCakePHP');
INSERT INTO `articles` (`id_article`, `title`, `content`) VALUES(23, 'Perl', 'Обзор[править | править вики-текст]\r\nPerl — язык программирования общего назначения, который был первоначально создан для манипуляций с текстом, но на данный момент используется для выполнения широкого спектра задач, включая системное администрирование, веб-разработку, сетевое программирование, игры, биоинформатику, разработку графических пользовательских интерфейсов.\r\n\r\nЯзык можно охарактеризовать скорее как практичный (лёгкость в использовании, эффективность, полнота), чем красивый (элегантность, минималистичность)[6]. Главными достоинствами языка являются поддержка различных парадигм (процедурный, объектно-ориентированный и функциональный стили программирования), контроль за памятью (без сборщика мусора, основанного на циклах), встроенная поддержка обработки текста, а также большая коллекция модулей сторонних разработчиков.\r\n\r\nСогласно Ларри Уоллу, у Perl есть два девиза. Первый — «Есть больше одного способа это сделать» («There’s more than one way to do it»), известный также под аббревиатурой TMTOWTDI. Второй слоган — «Простые вещи должны оставаться простыми, а сложные — стать выполнимыми» («Easy things should be easy and hard things should be possible»).\r\n\r\nОсобенности[править | править вики-текст]\r\nОбщая структура Perl в общих чертах ведёт своё начало от языка Си. Perl — процедурный по своей природе, имеет переменные, выражения присваивания, блоки кода, отделяемые фигурными скобками, управляющие структуры и функции.\r\n\r\nPerl также заимствует ряд свойств из языков программирования командных оболочек UNIX. Все переменные маркируются ведущими знаками, которые точно выражают тип данных переменной в этом контексте (например, скаляр, массив, хеш). Важно, что эти знаки позволяют переменным быть интерполированным в строках. Perl обладает множеством встроенных функций, которые обеспечивают инструментарий, часто используемый для программирования оболочки, например сортировку или вызов системных служб.\r\n\r\nPerl заимствует массивы из Лиспа, регулярные выражения из AWK и sed, из AWK также позаимствованы хеши («ассоциативные массивы»). Регулярные выражения облегчают выполнение многих задач по парсингу, обработке текста и манипуляций с данными.\r\n\r\nPerl 5 добавил поддержку сложных типов данных, первоклассных функций (замыкание как значение) и объектную модель. В последнюю входят ссылки, пакеты, выполнение методов от класса, переменные с лексическим объявлением области видимости, а также директивы компилятора (например, strict). Главнейшим усовершенствованием, представленным в Perl 5, стала возможность помещать код в «пакеты» (package) в качестве модулей для повторного использования. Ларри Уолл позже заметил, что «Весь замысел модульной системы Perl 5 сводился к поощрению роста культуры Perl, а не строчек кода»[7].\r\n\r\nВсе версии Perl выполняют автоматическую типизацию данных и автоматический контроль над памятью. Интерпретатор знает тип и запросы памяти каждого объекта программы, он распределяет и освобождает память, производя подсчёт ссылок. Перевод одного типа данных в другой — например, числа в строку — происходит автоматически во время исполнения, невозможные для выполнения переводы типов данных приводят к фатальной ошибке.\r\n\r\nРабота в Windows\r\nПользователи Microsoft Windows обычно используют дистрибутивы с уже скомпилированными бинарными файлами, такие, как ActivePerl или Strawberry Perl[en], так как компиляция Perl из исходных кодов в этой ОС — не самая простая задача. Задачу может облегчить Cygwin.\r\n\r\nИстория[править | править вики-текст]\r\nПервые версии[править | править вики-текст]\r\nЛарри Уолл начал разработку Perl в 1987 году, когда работал программистом в Unisys[8]. Версия 1.0 была выпущена и анонсирована в новостной группе comp.sources.misc 18 декабря 1987 года[9] как «„замена“ для awk и sed».\r\n\r\nPerl 2 был выпущен в 1988 году. Основным нововведением в нём был переработанный механизм регулярных выражений. Perl 3, выпущенный в 1989 году, получил возможность обрабатывать потоки двоичных данных.\r\n\r\nИзначально, единственной документацией для Perl была единственная (огромной длины) man-страница. В 1991 году была выпущена книга «Programming Perl» (известная многим программистам как «Верблюжья книга» (Camel Book) из-за изображения на обложке), которая, де-факто, стала стандартом языка. В то же самое время, версия языка была «поднята» до 4‑й — не столько чтобы указать на значительные изменения, сколько чтобы обозначить, что эта версия языка документирована книгой.\r\n\r\nРанний Perl 5[править | править вики-текст]\r\nPerl 4 прошёл через серию релизов, остановившись на Perl 4.036 в 1993 году. В этот момент Ларри Уолл забросил Perl 4 и начал работу над Perl 5. Разработка Perl 5 была начата в 1994 году. В то же время был создан список рассылки perl5-porters для координации работы над портированием Perl 5 на различные платформы. Он до сих пор остаётся основным форумом по разработке, обслуживанию и портированию Perl 5[10].\r\n\r\nPerl 5.000 был выпущен 17 октября 1994 года.[11] Он включал в себя полностью переписанный интерпретатор, а также много новых языковых возможностей, таких, как объекты, ссылки, локальные переменные (my $var_name) и модули. Особенно важной частью были модули, так как они предоставили механизм расширения языка без модифицирования интерпретатора. Это позволило стабилизировать интерпретатор, но при этом, дало возможность обычным Perl-программистам добавлять в язык новые возможности. Perl 5 находится в активной разработке по сей день.\r\n\r\nPerl 5.001 был выпущен 13 марта 1995 года. Perl 5.002 увидел свет 29 февраля 1996 года с новой поддержкой прототипов. Это позволило авторам модулей создавать функции, которые вели себя так же, как и встроенные функции Perl. Версия Perl 5.003 появилась 25 июня 1996 года и устранила обнаружившиеся проблемы с безопасностью.\r\n\r\nОдно из важнейших событий в истории Perl 5 случилось за пределами собственно языка и было следствием поддержки модулей. 26 октября 1995 года начала свою работу CPAN (Comprehensive Perl Archive Network — «всеобъемлющая сеть архивов Perl»), которая стала репозиторием модулей Perl, а также исходного кода самого языка. На данный момент сеть насчитывает более 25 000 модулей, созданных более чем 8000 программистами[12].\r\n\r\nPerl 5.004 был выпущен 15 мая 1997 года и содержал, кроме всего прочего, пакет UNIVERSAL, который давал языку основной объект, от которого автоматически происходили все классы. Была также включена возможность запрашивать версию модулей. В дополнение к этому Perl стал поддерживать Microsoft Windows, а также ряд других операционных систем.\r\n\r\nPerl 5.005 увидел свет 22 июня 1998 года. Этот релиз включал в себя несколько улучшений процессора регулярных выражений, новые перехваты в бэкенд с помощью модулей B::*, оператор кавычек qr// для регулярных выражений, большой выбор других новых модулей, а также поддержку ряда операционных систем, в частности, BeOS.\r\n\r\nC 2000 по наше время[править | править вики-текст]\r\nPerl 5.6 был выпущен 22 марта 2000 года. Главные изменения включали поддержку 64-битных систем, представление строк в стандарте Юникод, поддержку больших файлов (файлы больше 2 Гб) и ключевое слово our[13][14]. Во время разработки Perl 5.6 было принято решение изменить схему наименования версий на более близкую к другим проектам с открытым исходным кодом. За версией 5.005_63 следовала версия 5.5.640; согласно плану, версиям в разработке должны были присваиваться нечётные номера, стабильным версиям — чётные.\r\n\r\nВ 2000 году Ларри Уолл выступил с призывом к сообществу активно обсуждать предложения к следующей версии Perl. Результатом этого обсуждения стал 361 документ RFC (Request for Comments — «запрос комментариев»), которые были использованы в разработке Perl 6. В 2001 году[15] была начата работа над окончательным документом, подводящим итог предложениям к созданию нового поколения Perl. Результат был представлен не в виде формального документа, а в качестве сводки всех RFC. К этому времени Perl 6 существовал исключительно в виде описания языка.\r\n\r\nPerl 5.8 был впервые выпущен 18 июля 2002 года и с этого времени получал ежегодное обновление. Последняя версия Perl 5.8, под номером 5.8.9, увидела свет 14 декабря 2008 года. Perl 5.8 улучшил поддержку Юникода, добавил новую реализацию ввода-вывода, добавил поддержку многопоточности, увеличил числовую точность и добавил несколько новых модулей[16].\r\n\r\nВ 2004 году началась работа над Синопсисом (Synopsis) — первоначально задуманном как ряд документов, подводящих итоги окончательного документа, упоминавшегося выше. Однако постепенно этот ряд документов и стал спецификацией Perl 6. В феврале 2005 года Отриус Тан начала работу над Pugs[en] — интерпретатором Perl 6, написанном на Haskell[17]. Это было первой настоящей попыткой воплотить Perl 6 в реальность. Эта попытка заглохла в 2006 году.\r\n\r\n18 декабря 2007 года, в день 20-летней годовщины Perl 1.0, была выпущена версия Perl 5.10.0. Эта версия содержала в себе ряд заметных нововведений, приближающих её к Perl 6. Одними из таких нововведений стали новые операторы switch (названных «given»/«when»), обновление регулярных выражений, а также «умный» оператор совпадения «~~»[18][19].\r\n\r\nПримерно в это же время всерьёз началась разработка новой реализации Perl 6, известной как Rakudo Perl[en], разработанной в связке с виртуальной машиной Parrot. С ноября 2009 года Rakudo Perl регулярно обновляется каждый месяц и является на данный момент самой полной реализацией Perl 6.\r\n\r\nЗначительное изменение процесса разработки Perl 5 произошло после появления Perl 5.11. Сообщество разработчиков перешло на ежемесячный цикл выпусков, с планированием даты выпуска на три месяца вперёд.\r\n\r\n12 апреля 2010 года Perl 5.12.0 был представлен общественности. Выдающиеся нововведения включают в себя поддержку нового синтаксиса package NAME VERSION, оператор Yada Yada (служащего для маркировки кода-заполнителя, который ещё не реализован), полное решение «проблемы 2038 года» (Y2038), перегрузку операторов регулярных выражений, поддержку DTrace (фреймворка динамической трассировки), а также полную поддержку стандарта Unicode 5.2[20]. 7 сентября 2010 года был выпущен Perl 5.12.2, а 21 января 2011 — Perl 5.12.3. Эти выпуски содержат обновление модулей, а также некоторые изменения в документации[21][22]. Версия 5.12.4 выпущена 20 июня 2011. Последняя версия этой ветви, 5.12.5, выпущена 10 ноября 2012.\r\n\r\n14 мая 2011 выпущен Perl 5.14. Поддержка JSON стала встроенной, начиная с версии 5.14.2. Последняя версия этой ветви, 5.14.4, выпущена 10 марта 2013.\r\n\r\n20 мая 2012 выпущен Perl 5.16. Значимым новшеством является возможность указать нужную версию Perl, которую надо эмулировать, позволяя пользователям обновить Perl, но сохранить работоспособность старых скриптов, которые иначе стали бы несовместимыми с новой версией[23]. Ядро Perl 5.16 поддерживает Unicode 6.1[23].\r\n\r\n18 мая 2013 выпущен Perl 5.18. Значимые нововведения включают новые зацепки dtrace, лексические функции, увеличение числа включенных в ядро функций, пересмотр реализации хешей из соображений безопасности, поддержка Unicode 6.2[24].\r\n\r\nВерсия 5.20 вышла 27 мая 2014[25]. 16 апреля 2015 было объявлено о предполагавшемся выходе версии 5.22[26], а 9 мая 2016 вышла версия 5.24[27].\r\n\r\nAmbox outdated serious.svg\r\nИнформация в этой статье или некоторых её разделах устарела.\r\nВы можете помочь проекту, обновив её и убрав после этого данный шаблон.\r\nСопутствующие решения\r\nНекоторые наблюдатели приписывают выходу Perl 5.10 запуск движения Modern Perl[28][29]. В частности, эта фраза описывает стиль разработки, подразумевающий использование CPAN, использование преимуществ последних разработок на языке, а также требовательность к высокому качеству кода[30].\r\n\r\nВ конце 2012 и в 2013 запущены несколько проектов по альтернативной реализации Perl 5: Perl5 in Perl6 (Rakudo Perl team)[31], moe (Стивен Литл с друзьями)[32], p2[33] (Perl11 team under Reini Urban), а также gperl (goccy)[34].\r\n\r\nPerl 6[править | править вики-текст]\r\nОсновная статья: Perl 6\r\nС 2000 года идёт разработка новой (6-й) версии языка. В отличие от предыдущих версий, разработчики планируют создать чётко определённый стандарт языка. В настоящее время существуют экспериментальные компиляторы Perl 6, но продолжается дальнейшее обсуждение новых правил.\r\n\r\nСинтаксис языка Perl[править | править вики-текст]\r\nСинтаксис Perl имеет много общего с синтаксисом языков Си, AWK, sed и Bourne shell.\r\n\r\nПервая строка исходного кода может начинаться с «#!/Путь/к/Perl [-ключи]» — что указывает системе путь к интерпретатору Perl для выполнения программы в UNIX-системах и выполнения их на веб-сервере (см. также: Шебанг (Unix)).\r\n\r\nПример программы[править | править вики-текст]\r\nПростейшая программа «Hello, world!» выглядит следующим образом:\r\n\r\n#!/usr/bin/perl\r\nprint "Hello, world!\\n";\r\nлибо для CGI:\r\n\r\n#!/usr/bin/perl\r\nprint "Content-type: text/html\\n\\n";\r\nprint "Hello, world!";\r\nлибо используя один из post modern web-framework\r\n\r\nuse Mojolicious::Lite;\r\nget ''/'' => {text => ''Hello World!''};\r\napp->start;\r\nлибо используя PSGI спецификацию\r\n\r\nmy $app = sub {\r\n    return [200, [''Content-Type'' => ''text/plain''], ["hello, world\\n"]];\r\n}\r\nДозапись в строку.\r\n\r\n$x = 5;\r\n$x .= 0;\r\nprint $x; #50\r\nА вот так можно напечатать число гугол.\r\n\r\nprint 1, 0 x 100;\r\nТипы данных[править | править вики-текст]\r\nОсновные типы данных: скаляр, массив, хеш-таблица, функция, указание на файл, запись таблицы символов. Переменные разных типов отличаются знаком, который стоит перед именем переменной:\r\n\r\nТип	Символ	Пример	Описание\r\nСкаляр	$	$foo	единичное значение; может быть числом, строкой, указанием на файл, а также ссылкой.\r\nМассив	@	@foo	Упорядоченная коллекция скаляров.\r\nХеш-таблица	%	%foo	Коллекция из пар строка-скаляр; строки называются ключами, а скаляры — значениями. Синоним — ассоциативный массив.\r\nФайловый дескриптор	< >	$foo или FOO	Представление открытого файла или другой цели, открытой для чтения и/или записи.\r\nФункция	&	&foo	Отрезок кода, который принимает аргументы, исполняет действия и возвращает значения.\r\nЗапись таблицы символов	*	*foo	Запись таблицы символов для всех типов с именем ''foo''.\r\nСкаляр[править | править вики-текст]\r\nСкалярные переменные используются для хранения одиночных значений. Они могут содержать числа, строки и ссылки на другие объекты. Перед именем скалярной переменной необходимо ставить знак доллара ''$''. Тип скалярной переменной не фиксирован (в отличие от, например, языка Си) и определяется динамически в зависимости от контекста. Например,\r\n\r\n$x = 10; # число\r\n$y = $x + 1; # используем $x как число…\r\n$z = $x . ''string''; # … а теперь — как строку\r\n$ref = \\$x;  # $ref является указателем на $x\r\n$$ref = 10; # $x содержит значение 10\r\nСтроковые данные должны быть помещены в кавычки. Perl использует два вида кавычек — одиночные и двойные. Помещение строки в двойные кавычки позволяет именам переменных, содержащимся в строке, автоматически заменить собою название переменных. Заключение строк в одиночные кавычки предотвращает такое поведение:\r\n\r\n## Пример интерполяции переменных в двойных кавычках\r\n\r\n$pi             = 3.141592654;\r\n$var1           = ''Значение Pi - $pi\\n'';  \r\nprint $var1;                                                 # Значение Pi - $pi\\n\r\n$var2           = "Значение Pi - $pi\\n";\r\nprint $var2;                                                 # Значение Pi - 3.141592654\r\nДля включения двойных кавычек в строку, которая была помещена в двойные кавычки, следует использовать отмену знака — \\". Для включения одинарных кавычек в строку из одинарных кавычек — \\''. Для удобства работы со строками, содержащими много знаков кавычек внутри, Perl позволяет использовать альтернативные способы закавычивания. Альтернативная форма использует любую пару знаков, помещённых после буквы q (имитирует поведение одинарных кавычек) или qq (имитирует поведение двойных кавычек):\r\n\r\n## Пример использования альтернативных кавычек\r\n\r\n$pi       = 3.141592654;\r\n$link1    = q{<a href="http://ru.wikipedia.org/wiki/Pi">$pi</a>};\r\nprint $link1;                                              # <a href="http://ru.wikipedia.org/wiki/Pi">$pi</a>\r\n$link2    = qq{<a href="http://ru.wikipedia.org/wiki/Pi">$pi</a>};\r\nprint $link2;                                              # <a href="http://ru.wikipedia.org/wiki/Pi">3.141592654</a>\r\nЕщё один тип кавычек в Perl — обратные кавычки. В них помещаются программы операционной системы, вывод которых может быть передан интерпретатору Perl. Выполнение программ всегда заканчиваются символом новой строки — \\n:\r\n\r\n## Пример использования обратных кавычек для исполнения команд UNIX\r\n\r\n$space		= `du -s -k /usr/local/bin`;\r\nprint $space;                                   # 6264	/usr/local/bin\r\n\r\n$sysuptime	= `uptime`;	\r\nprint $sysuptime;                               # 2:24  up 1 day,  9:05, 1 user, load averages: 0.26 0.32 0.33\r\nМассив[править | править вики-текст]\r\nМассив является упорядоченным списком скаляров. Каждый элемент массива имеет порядковый индекс, с помощью которого к нему можно получить доступ. Нумерация элементов начинается с нуля, то есть первый элемент списка имеет индекс 0. Перед именем переменной-массива необходимо ставить знак ''@'', а для доступа к определенному элементу массива использовать знак ''$'', так как отдельный');

-- --------------------------------------------------------

--
-- Структура таблицы `privs`
--

CREATE TABLE IF NOT EXISTS `privs` (
  `id_priv` int(5) NOT NULL,
  `name` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `privs`
--

INSERT INTO `privs` (`id_priv`, `name`, `description`) VALUES(1, 'USE_SECRET_FUNCTIONS', 'Привилегия для примера');
INSERT INTO `privs` (`id_priv`, `name`, `description`) VALUES(2, 'VIEW_CONTACT', 'отображение контактов');
INSERT INTO `privs` (`id_priv`, `name`, `description`) VALUES(3, 'VIEW_SALARY', 'отображение зарплаты');

-- --------------------------------------------------------

--
-- Структура таблицы `privs2roles`
--

CREATE TABLE IF NOT EXISTS `privs2roles` (
  `id_priv` int(5) NOT NULL,
  `id_role` int(5) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `privs2roles`
--

INSERT INTO `privs2roles` (`id_priv`, `id_role`) VALUES(1, 1);
INSERT INTO `privs2roles` (`id_priv`, `id_role`) VALUES(2, 3);
INSERT INTO `privs2roles` (`id_priv`, `id_role`) VALUES(3, 2);

-- --------------------------------------------------------

--
-- Структура таблицы `roles`
--

CREATE TABLE IF NOT EXISTS `roles` (
  `id_role` int(5) NOT NULL,
  `name` varchar(255) NOT NULL,
  `description` varchar(255) DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `roles`
--

INSERT INTO `roles` (`id_role`, `name`, `description`) VALUES(1, 'test', 'Роль для примера');
INSERT INTO `roles` (`id_role`, `name`, `description`) VALUES(2, 'finans', 'Роль финансы');

-- --------------------------------------------------------

--
-- Структура таблицы `sessions`
--

CREATE TABLE IF NOT EXISTS `sessions` (
  `id_session` int(11) NOT NULL,
  `id_user` int(11) NOT NULL,
  `sid` varchar(10) NOT NULL,
  `time_start` datetime NOT NULL,
  `time_last` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE IF NOT EXISTS `users` (
  `id_user` int(5) NOT NULL,
  `username` varchar(255) NOT NULL,
  `password` varchar(32) NOT NULL,
  `id_role` int(5) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`id_user`, `username`, `password`, `id_role`, `name`) VALUES(1, 'test', '098f6bcd4621d373cade4e832627b4f6', 1, 'test');
INSERT INTO `users` (`id_user`, `username`, `password`, `id_role`, `name`) VALUES(2, 'test2', '098f6bcd4621d373cade4e832627b4f6', 2, 'fin');
INSERT INTO `users` (`id_user`, `username`, `password`, `id_role`, `name`) VALUES(3, 'test3', '098f6bcd4621d373cade4e832627b4f6', 3, 'contact');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`id_article`);

--
-- Индексы таблицы `privs`
--
ALTER TABLE `privs`
  ADD PRIMARY KEY (`id_priv`),
  ADD UNIQUE KEY `name` (`name`);

--
-- Индексы таблицы `privs2roles`
--
ALTER TABLE `privs2roles`
  ADD PRIMARY KEY (`id_priv`,`id_role`);

--
-- Индексы таблицы `roles`
--
ALTER TABLE `roles`
  ADD PRIMARY KEY (`id_role`),
  ADD UNIQUE KEY `name` (`name`);

--
-- Индексы таблицы `sessions`
--
ALTER TABLE `sessions`
  ADD PRIMARY KEY (`id_session`),
  ADD UNIQUE KEY `sid` (`sid`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id_user`),
  ADD UNIQUE KEY `login` (`username`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `articles`
--
ALTER TABLE `articles`
  MODIFY `id_article` int(11) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=24;
--
-- AUTO_INCREMENT для таблицы `privs`
--
ALTER TABLE `privs`
  MODIFY `id_priv` int(5) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=4;
--
-- AUTO_INCREMENT для таблицы `roles`
--
ALTER TABLE `roles`
  MODIFY `id_role` int(5) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=3;
--
-- AUTO_INCREMENT для таблицы `sessions`
--
ALTER TABLE `sessions`
  MODIFY `id_session` int(11) NOT NULL AUTO_INCREMENT;
--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `id_user` int(5) NOT NULL AUTO_INCREMENT,AUTO_INCREMENT=4;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
